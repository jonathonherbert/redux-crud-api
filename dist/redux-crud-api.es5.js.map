{"version":3,"file":"redux-crud-api.es5.js","sources":["../src/createAPIResource.ts"],"sourcesContent":["import filter from \"lodash-es/filter\";\nimport find from \"lodash-es/find\";\nimport identity from \"lodash-es/identity\";\nimport kebabCase from \"lodash-es/kebabCase\";\nimport noop from \"lodash-es/noop\";\nimport orderBy from \"lodash-es/orderBy\";\nimport { ObjectIterator } from \"lodash\";\nimport { normalize, Schema } from \"normalizr\";\nimport * as qs from \"querystring\";\nimport { batchActions } from \"redux-batched-actions\";\nimport { Dispatch } from \"redux\";\nimport reduxCrud from \"redux-crud\";\nimport v4 from \"uuid/v4\";\nimport \"whatwg-fetch\";\n\n// The names we use for actions don't map to the redux-crud action names, so we do that here.\nexport const mapActionToCRUDAction = {\n  create: \"create\",\n  del: \"delete\",\n  fetch: \"fetch\",\n  search: \"fetch\",\n  update: \"update\"\n};\n\nexport type MapActionToCRUDAction = typeof mapActionToCRUDAction;\n\nexport type ActionTypes = keyof MapActionToCRUDAction;\nexport type CRUDActionTypes = MapActionToCRUDAction[keyof MapActionToCRUDAction];\n\n// The names we use for actions also must map to the http methods.\nconst mapActionToHTTPMethod = {\n  create: \"post\",\n  update: \"put\",\n  del: \"delete\",\n  fetch: \"get\",\n  search: \"get\"\n} as { [action: string]: string };\n\n// The default actions available.\nconst availableActions: ActionTypes[] = [\"create\", \"update\", \"del\", \"fetch\", \"search\"];\n\ninterface ICreateAPIActionOptions {\n  // The name of the resource, in the singular\n  resourceName: string;\n  // The action creators generated by redux-crud\n  actionCreators: any;\n  // The selectors generated by redux-crud\n  selectors: any;\n  // The name of the action to dispatch\n  actionName: ActionTypes;\n  // The HTTP method\n  method: string;\n  // The base url for the API action\n  baseUrl: string;\n  // Will be used to set basic auth headers\n  selectAuthToken?: (state: any) => string;\n  // The relations of the model being used\n  relations: any;\n  // The function that models are passed through when they're received\n  transformIn: (model: any) => any;\n  // The function that models are passed through when they're sent\n  transformOut: (model: any) => any;\n}\n\nexport interface IAPIActionOptions {\n  // The endpoint for requests.\n  endpoint?: string;\n  // The content-type that should be set in request headers.\n  contentType?: string;\n}\n\nexport interface IAPIActionParams {\n  resource: any;\n  options?: IAPIActionOptions;\n}\n\nexport type IAPIActionCreator = (\n  params?: IAPIActionParams\n) => (dispatch: Dispatch<any>, getState: () => any) => Promise<any>;\n\n/**\n * Get the request body for a given API action.\n */\nconst getRequestBody = ({\n  resource,\n  transformOut,\n  actionName,\n  contentType\n}: {\n  resource: any;\n  transformOut: (resource: any) => any;\n  actionName: string;\n  contentType: string;\n}) => {\n  const resourceToSend = transformOut({ ...resource });\n  if (actionName === \"create\") {\n    delete resourceToSend.id;\n  }\n  return createRequestBody(contentType, resourceToSend);\n};\n\nconst getContentType = (options?: IAPIActionOptions) => {\n  return options && options.contentType ? options.contentType : \"application/json\";\n};\n\n/**\n * Get the request headers for a given API action. These include the content type\n * and any necessary authorisation tokens.\n *\n * @param {string} method\n * @param {IAPIOptions} options\n * @param selectAuthToken\n */\nconst getRequestHeaders = (method: string, contentType: string, authToken?: string) => {\n  const headers = new Headers();\n  if ((method === \"post\" || method === \"put\") && contentType !== \"multipart/form-data\") {\n    headers.append(\"content-type\", contentType);\n  }\n\n  // Add the authentication code to the header, if we have it\n  if (authToken) {\n    headers.append(\"authorization\", `Bearer ${authToken}`);\n  }\n  return headers;\n};\n\n/**\n * Creates a request body given a content type.\n *\n * @param {string} contentType e.g. application/json\n * @param {any} resource The resource to send.\n * @return {any} The request body data\n */\nconst createRequestBody = (contentType: string, resource: any) => {\n  switch (contentType) {\n    case \"application/json\":\n      return JSON.stringify(resource);\n    case \"multipart/form-data\":\n      const formData = new FormData();\n      for (const name in resource) {\n        formData.append(name, resource[name]);\n      }\n      return formData;\n    default:\n      throw new Error(\n        `Could not create request body: there is no handler for content-type: ${contentType}`\n      );\n  }\n};\n\n/**\n * Get the request options for the API action.\n */\nconst getRequestOptions = ({\n  method,\n  contentType,\n  authToken,\n  resource,\n  transformOut,\n  actionName\n}: {\n  resource: any;\n  transformOut: (resource: any) => any;\n  actionName: string;\n  contentType: string;\n  method: string;\n  authToken?: string;\n}) => {\n  const requestOptions = {\n    method: method.toUpperCase(),\n    headers: getRequestHeaders(method, contentType, authToken)\n  } as {\n    method: string;\n    headers: Headers;\n    body?: string | FormData;\n  };\n  if (method === \"post\" || method === \"put\") {\n    requestOptions.body = getRequestBody({ resource, transformOut, actionName, contentType });\n  }\n  return requestOptions;\n};\n\n/**\n * Get the relative request string for a given API action.\n *\n * @param {string} method\n * @param {string} actionName\n * @param {any} resource\n * @param {string} resourceName\n * @param {IAPIActionOptions} options\n */\nconst getRequestString = ({\n  method,\n  actionName,\n  resource,\n  resourceName,\n  options\n}: {\n  method: string;\n  actionName: string;\n  resource: any;\n  resourceName: string;\n  options?: IAPIActionOptions;\n}): string => {\n  let requestString = \"\";\n  if (options && options.endpoint) {\n    requestString += `/${options.endpoint}`;\n  } else {\n    requestString = `/${kebabCase(resourceName)}`;\n  }\n  // If we have a specific resource or request type, append it to request URL\n  if (\n    (method === \"get\" && actionName !== \"search\" && resource.id) ||\n    method === \"delete\" ||\n    method === \"put\"\n  ) {\n    requestString += `/${resource.id}`;\n  }\n  if (actionName === \"search\") {\n    requestString += `/search?${qs.stringify(resource)}`;\n  }\n  return requestString;\n};\n\n/**\n * Get data from the API response.\n */\nasync function getDataFromAPIResponse({\n  response,\n  resource,\n  actionName,\n  transformIn\n}: {\n  response: Response;\n  resource: any;\n  actionName: string;\n  transformIn: (resource: any) => any;\n}) {\n  if (response.status < 200 || response.status > 299) {\n    throw new Error(`HTTP Error: ${response.status}`);\n  }\n  let data;\n  if (actionName === \"del\") {\n    data = resource;\n  } else {\n    // We take the data from the 'data' envelope, if it exists,\n    // or from the json directly if it doesn't.\n    // It'd be good to let the user provide an envelope.\n    const json: { data: any } = await response.json();\n    data = json.data ? json.data : json;\n    // Apply transforms\n    const dataIsArray = Array.isArray(data);\n    if (dataIsArray) {\n      data = data.map((item: any) => transformIn(item));\n    } else {\n      data = transformIn(data);\n    }\n  }\n  return data;\n}\n\n/**\n * Creates a saga that handles API operations.\n * Updates optimistically when updating or creating.\n *\n * @param {ICreateAPIActionOptions}\n */\nfunction createAPIAction({\n  resourceName,\n  baseUrl,\n  actionCreators,\n  actionName,\n  method,\n  selectAuthToken,\n  selectors,\n  relations,\n  transformIn,\n  transformOut\n}: ICreateAPIActionOptions): IAPIActionCreator {\n  /**\n   * Generator for the given action.\n   * Accepts FSA containing a payload with property 'resource' containing request data.\n   * Dispatches start (if applicable) action, makes HTTP calls, dispatches success/error actions with result.\n   */\n  return (payload?: IAPIActionParams) => async (dispatch: Dispatch<any>, getState: () => any) => {\n    // We store a client id here for optimistic creation\n    let resource;\n    let options;\n    let cid;\n    let authToken;\n    const state = getState();\n    const relationKeys = {} as { [relationId: string]: any[] };\n    const crudAction = mapActionToCRUDAction[actionName];\n    if (payload) {\n      ({ resource, options } = payload);\n    }\n    if (selectAuthToken) {\n      authToken = selectAuthToken(state);\n    }\n\n    let localResource = { ...resource };\n\n    // If we're creating a record, give it the client id if it doesn't have one already\n    if (actionName === \"create\") {\n      cid = localResource.id ? localResource.id : (localResource.id = v4());\n    }\n\n    // If we're updating a model, merge it with what's current in the state\n    if (actionName === \"update\") {\n      const modelFromState = selectors.findById(state, localResource.id);\n      if (!modelFromState) {\n        throw new Error(`Could not select model with id ${resource.id}`);\n      }\n      localResource = { ...modelFromState, ...localResource };\n    }\n\n    // Dispatch our start action, if there is one for the given action\n    if (resource && actionCreators[crudAction + \"Start\"]) {\n      if (relations && (actionName === \"update\" || actionName === \"create\")) {\n        const schema = Array.isArray(localResource) ? [relations.schema] : relations.schema;\n        const normalisedResource = normalize(localResource, schema);\n        for (const i in relations.map) {\n          const relationData = normalisedResource.entities[i];\n          if (!relationData) {\n            continue;\n          }\n          // We store relation keys (cids) in order here.\n          // When we receive relation updates at the end of the action,\n          // we can replay these keys in order to sync with optimistic updates.\n          relationKeys[i] = [];\n          const actions: any[] = [];\n\n          if (relationData.undefined) {\n            console.warn(`One or more of the relations you\\'re trying to ${actionName} is missing an id.\\\n\t\t\t\t\t\t\tBad things are likely to happen as a result.`);\n          }\n          Object.keys(relationData).forEach(id => {\n            relationKeys[i].push(id);\n            actions.push(relations.map[i][crudAction + \"Start\"](relationData[id]));\n          });\n          dispatch(batchActions(actions));\n        }\n      } else {\n        dispatch(actionCreators[crudAction + \"Start\"](localResource));\n      }\n    }\n\n    const contentType = getContentType(options);\n    const requestOptions = getRequestOptions({\n      resource: localResource,\n      actionName,\n      method,\n      contentType,\n      authToken,\n      transformOut\n    });\n    const requestString = getRequestString({\n      resource: localResource,\n      actionName,\n      method,\n      resourceName,\n      options\n    });\n\n    // Make the request and handle the response\n    try {\n      const response = await fetch(baseUrl + requestString, requestOptions);\n      const data = await getDataFromAPIResponse({\n        resource: localResource,\n        response,\n        actionName,\n        transformIn\n      });\n      // If there aren't any relations or we're not running a fetch or update, do a basic persist\n      if (!relations || (crudAction !== \"fetch\" && crudAction !== \"update\")) {\n        if (actionName === \"create\") {\n          dispatch(actionCreators[crudAction + \"Success\"](data, cid));\n        } else {\n          dispatch(actionCreators[crudAction + \"Success\"](data));\n        }\n      } else {\n        // If we do have relations, normalise the incoming data, and dispatch persist\n        // operations for each model. We check here to see if the data is an array (collection),\n        // and adjust the schema accordingly.\n        const normalisedData = normalize(\n          data,\n          Array.isArray(data) ? [relations.schema] : relations.schema\n        );\n        for (const i in relations.map) {\n          const relationData = normalisedData.entities[i];\n          if (!relationData) {\n            continue;\n          }\n          const actions: any[] = [];\n          Object.keys(relationData).forEach((id, index) => {\n            if (crudAction === \"fetch\") {\n              actions.push(relations.map[i][crudAction + \"Success\"](relationData[id]));\n            } else {\n              // We use the previously stored cid to reconcile updates here.\n              // It's imperative that relations come back in the same order they went out!\n              actions.push(\n                relations.map[i][crudAction + \"Success\"](\n                  relationData[id],\n                  relationKeys[i] ? relationKeys[i][index] : null\n                )\n              );\n            }\n          });\n          dispatch(batchActions(actions));\n        }\n      }\n      // Once we're done, call resolve for the Promise caller\n      return data;\n    } catch (e) {\n      if (method === \"get\") {\n        dispatch(actionCreators[crudAction + \"Error\"](e.message));\n      } else {\n        // Methods that persist data require the resource to revert optimistic updates\n        dispatch(actionCreators[crudAction + \"Error\"](e.message, localResource));\n      }\n      throw e;\n    }\n  };\n}\n\n// Selectors\n// ---------\n\n/**\n * Create selectors for the given resource namespace.\n *\n * @param {string} mountPoint - The name of the resource as appears in the state\n * @return {any} Object with selector methods\n */\nfunction createSelectors<IResource extends IBaseResource>(mountPoint: string) {\n  const getLocalState = (state: any): IState<IResource> => state[mountPoint];\n  return {\n    /**\n     * @inheritdocs\n     */\n    findById(state: any, id: number | string) {\n      return getLocalState(state).records[id] || null;\n    },\n\n    /**\n     * @inheritdocs\n     */\n    findByCid(state: any, cid: number | string) {\n      return find(\n        getLocalState(state).records,\n        (item: { _cid?: number | string }) => item._cid === cid\n      );\n    },\n\n    /**\n     * @inheritdocs\n     */\n    filter(\n      state: any,\n      predicate:\n        | string\n        | [string, any]\n        | ObjectIterator<\n            {\n              [key: string]: IResource;\n            },\n            boolean\n          >\n    ) {\n      return filter(getLocalState(state).records, predicate);\n    },\n\n    orderBy(state: any, iteratees: string[] | string, order: string[] | string) {\n      return orderBy(getLocalState(state).records, iteratees, order);\n    },\n\n    /**\n     * @inheritdocs\n     */\n    findAll(state: any) {\n      return getLocalState(state).records;\n    },\n\n    isResourceBusy(state: any, id: number | string) {\n      const records = getLocalState(state).records;\n      return Object.keys(records).some(id => !!records[id].busy);\n    },\n\n    isBusy(state: any, id: number | string) {\n      const record = getLocalState(state).records[id];\n      return record ? !!record.busy : false;\n    },\n\n    isPendingUpdate(state: any, id: number | string) {\n      const record = getLocalState(state).records[id];\n      return record ? !!record.pendingUpdate : false;\n    },\n\n    isPendingCreate(state: any, id: number | string) {\n      const record = getLocalState(state).records[id];\n      return record ? !!record.pendingCreate : false;\n    },\n\n    lastFetch(state: any) {\n      return getLocalState(state).lastFetch;\n    }\n  };\n}\n\nexport interface ICreateAPIResourceOptions {\n  // The name of the resource, conventionally in the singular\n  resourceName: string;\n  // The base url of the resource\n  baseUrl: string;\n  // The actions to add to the returned object\n  actions?: Array<ActionTypes>;\n  // Will be used to set basic auth headers\n  selectAuthToken?: (state: any) => string;\n  /**\n   * The relations options. We provide a Normalizr Schema object\n   * \there to process the incoming data, and a map between any additional entity names and\n   * \ttheir reducer functions. For example:\n   * ```js{\n   * \tschema: book,\n   * \tmap: {\n   * \t\tauthor: author.actions\n   * \t}\n   * }```\n   * would update authors nested in data returned from the Book resource.\n   */\n  relations?: {\n    schema: Schema;\n    map: {\n      [key: string]: any;\n    };\n  };\n  options?: {\n    // The function that models are passed through when they're received\n    transformIn: (model: any) => any;\n    // The function that models are passed through when they're sent\n    transformOut: (model: any) => any;\n  };\n}\n\nexport interface IBaseResource {\n  id: number | string;\n  _cid?: number | string;\n  busy?: boolean;\n  pendingUpdate?: boolean;\n  pendingCreate?: boolean;\n}\n\nexport interface IState<IResource extends IBaseResource> {\n  records: { [key: string]: IResource };\n  lastFetch: number | null;\n}\n\nconst initialState = {\n  records: {},\n  lastFetch: null\n};\n\n/**\n * Create the reduce for the given resource.\n */\nexport const createReducer = <\n  IResource extends IBaseResource,\n  IAction extends { type: string; time?: number }\n>(\n  resourceName: string\n) => {\n  const recordReducer = reduxCrud.Map.reducersFor(resourceName);\n  return (state: IState<IResource> = initialState, action: IAction): IState<IResource> => {\n    const newState = {\n      ...state,\n      records: recordReducer(state.records, action)\n    };\n    if (action.type.indexOf(\"SUCCESS\") !== -1 && action.time) {\n      newState.lastFetch = action.time;\n    }\n    return newState;\n  };\n};\n\n/**\n * Create the action creators for the given resource.\n *\n * We augment some of the default 'success' action creators here to include a time property,\n * which lets the reducer store staleness information.\n */\nexport const createActionCreators = (resourceName: string) => {\n  const rawActionCreators = reduxCrud.actionCreatorsFor(resourceName);\n  const actionCreators = { ...rawActionCreators };\n  actionCreators.fetchSuccess = (records?: {}[] | undefined, data?: any) => {\n    return {\n      ...rawActionCreators.fetchSuccess(records, data),\n      time: Date.now()\n    };\n  };\n  actionCreators.updateSuccess = (records?: {} | undefined, data?: any) => {\n    return {\n      ...rawActionCreators.updateSuccess(records, data),\n      time: Date.now()\n    };\n  };\n  actionCreators.createSuccess = (records?: {} | undefined, data?: any) => {\n    return {\n      ...rawActionCreators.createSuccess(records, data),\n      time: Date.now()\n    };\n  };\n  return actionCreators;\n};\n\ntype TActionMap = ReturnType<typeof reduxCrud.actionCreatorsFor>;\ntype TActions = ReturnType<TActionMap[keyof TActionMap]>;\n\n/**\n * Creates an object with api methods keyed by name.\n * All of these actions can be dispatched as normal.\n * They will dispatch start (where available), success and error actions\n * in turn, making the http request to the API, the idea being, generic CRUD.\n *\n * @returns {IAPIResource}\n */\nfunction createAPIResource<IResource extends IBaseResource>({\n  resourceName,\n  baseUrl,\n  actions = availableActions,\n  selectAuthToken,\n  relations,\n  options = {\n    transformIn: identity,\n    transformOut: identity\n  }\n}: ICreateAPIResourceOptions) {\n  const actionCreators = createActionCreators(resourceName);\n  const selectors = createSelectors<IResource>(resourceName);\n  const actionNames = reduxCrud.actionTypesFor(resourceName);\n  const apiResource = {\n    thunks: {} as { [action: string]: IAPIActionCreator },\n    actions: actionCreators,\n    actionNames: {} as { [actionName: string]: string },\n    selectors,\n    reducers: createReducer<IResource, TActions>(resourceName)\n  };\n\n  // Create a resource for each of our actions\n  actions.forEach(actionName => {\n    if (!mapActionToHTTPMethod[actionName]) {\n      throw new Error(`Method ${actionName} not supported for resource ${resourceName}`);\n    }\n\n    // If we've got relations, add the root relation to the relations map.\n    // This saves us doing it for every persist operation, and lets us iterate\n    // over the whole resource with the relations map.\n    if (relations) {\n      relations.map[resourceName] = actionCreators;\n    }\n\n    apiResource.actionNames = actionNames;\n\n    // Create the worker saga\n    apiResource.thunks[actionName] = createAPIAction({\n      resourceName,\n      baseUrl,\n      actionCreators,\n      selectors,\n      actionName,\n      method: mapActionToHTTPMethod[actionName],\n      selectAuthToken,\n      relations,\n      transformIn: options.transformIn || identity,\n      transformOut: options.transformOut || identity\n    });\n  });\n  return apiResource;\n}\n\nexport default createAPIResource;\n"],"names":["qs.stringify"],"mappings":"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"}