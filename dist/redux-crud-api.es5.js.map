{"version":3,"file":"redux-crud-api.es5.js","sources":["../src/createAPIResource.ts"],"sourcesContent":["import filter from \"lodash/filter\";\nimport find from \"lodash/find\";\nimport identity from \"lodash/identity\";\nimport kebabCase from \"lodash/kebabCase\";\nimport noop from \"lodash/noop\";\nimport orderBy from \"lodash/orderBy\";\nimport { ObjectIterator } from \"lodash\";\nimport { normalize, Schema } from \"normalizr\";\nimport * as qs from \"querystring\";\nimport { batchActions } from \"redux-batched-actions\";\nimport { Dispatch } from \"redux\";\nimport reduxCrud from \"redux-crud\";\nimport v4 from \"uuid/v4\";\n\n// The names we use for actions don't map to the redux-crud action names, so we do that here.\nexport const mapActionToCRUDAction = {\n  create: \"create\",\n  del: \"delete\",\n  fetch: \"fetch\",\n  search: \"fetch\",\n  update: \"update\"\n};\n\nexport type MapActionToCRUDAction = typeof mapActionToCRUDAction;\n\nexport type ActionTypes = keyof MapActionToCRUDAction;\nexport type CRUDActionTypes = MapActionToCRUDAction[keyof MapActionToCRUDAction];\n\n// The names we use for actions also must map to the http methods.\nconst mapActionToHTTPMethod = {\n  create: \"post\",\n  update: \"put\",\n  del: \"delete\",\n  fetch: \"get\",\n  search: \"get\"\n} as { [action: string]: string };\n\n// The default actions available.\nconst availableActions: ActionTypes[] = [\"create\", \"update\", \"del\", \"fetch\", \"search\"];\n\ninterface ICreateAPIActionOptions {\n  // The name of the resource, in the singular\n  resourceName: string;\n  // The action creators generated by redux-crud\n  actionCreators: any;\n  // The selectors generated by redux-crud\n  selectors: any;\n  // The name of the action to dispatch\n  actionName: ActionTypes;\n  // The HTTP method\n  method: string;\n  // The base url for the API action\n  baseUrl: string;\n  // Will be used to set basic auth headers\n  selectAuthToken?: (state: any) => string;\n  // The relations of the model being used\n  relations: any;\n  // The function that models are passed through when they're received\n  transformIn: (model: any) => any;\n  // The function that models are passed through when they're sent\n  transformOut: (model: any) => any;\n}\n\nexport interface IAPIActionOptions {\n  // The endpoint for requests.\n  endpoint?: string;\n  // The content-type that should be set in request headers.\n  contentType?: string;\n}\n\nexport interface IAPIActionParams {\n  resource: any;\n  options?: IAPIActionOptions;\n}\n\nexport type IAPIActionCreator = (\n  params?: IAPIActionParams\n) => (dispatch: Dispatch<any>, getState: () => any) => Promise<any>;\n\n/**\n * Get the request body for a given API action.\n */\nconst getRequestBody = ({\n  resource,\n  transformOut,\n  actionName,\n  contentType\n}: {\n  resource: any;\n  transformOut: (resource: any) => any;\n  actionName: string;\n  contentType: string;\n}) => {\n  const resourceToSend = transformOut({ ...resource });\n  if (actionName === \"create\") {\n    delete resourceToSend.id;\n  }\n  return createRequestBody(contentType, resourceToSend);\n};\n\nconst getContentType = (options?: IAPIActionOptions) => {\n  return options && options.contentType ? options.contentType : \"application/json\";\n};\n\n/**\n * Get the request headers for a given API action. These include the content type\n * and any necessary authorisation tokens.\n *\n * @param {string} method\n * @param {IAPIOptions} options\n * @param selectAuthToken\n */\nconst getRequestHeaders = (method: string, contentType: string, authToken?: string) => {\n  const headers = new Headers();\n  if ((method === \"post\" || method === \"put\") && contentType !== \"multipart/form-data\") {\n    headers.append(\"content-type\", contentType);\n  }\n\n  // Add the authentication code to the header, if we have it\n  if (authToken) {\n    headers.append(\"authorization\", `Bearer ${authToken}`);\n  }\n  return headers;\n};\n\n/**\n * Creates a request body given a content type.\n *\n * @param {string} contentType e.g. application/json\n * @param {any} resource The resource to send.\n * @return {any} The request body data\n */\nconst createRequestBody = (contentType: string, resource: any) => {\n  switch (contentType) {\n    case \"application/json\":\n      return JSON.stringify(resource);\n    case \"multipart/form-data\":\n      const formData = new FormData();\n      for (const name in resource) {\n        formData.append(name, resource[name]);\n      }\n      return formData;\n    default:\n      throw new Error(\n        `Could not create request body: there is no handler for content-type: ${contentType}`\n      );\n  }\n};\n\n/**\n * Get the request options for the API action.\n */\nconst getRequestOptions = ({\n  method,\n  contentType,\n  authToken,\n  resource,\n  transformOut,\n  actionName\n}: {\n  resource: any;\n  transformOut: (resource: any) => any;\n  actionName: string;\n  contentType: string;\n  method: string;\n  authToken?: string;\n}) => {\n  const requestOptions = {\n    method: method.toUpperCase(),\n    headers: getRequestHeaders(method, contentType, authToken)\n  } as {\n    method: string;\n    headers: Headers;\n    body?: string | FormData;\n  };\n  if (method === \"post\" || method === \"put\") {\n    requestOptions.body = getRequestBody({ resource, transformOut, actionName, contentType });\n  }\n  return requestOptions;\n};\n\n/**\n * Get the relative request string for a given API action.\n *\n * @param {string} method\n * @param {string} actionName\n * @param {any} resource\n * @param {string} resourceName\n * @param {IAPIActionOptions} options\n */\nconst getRequestString = ({\n  method,\n  actionName,\n  resource,\n  resourceName,\n  options\n}: {\n  method: string;\n  actionName: string;\n  resource: any;\n  resourceName: string;\n  options?: IAPIActionOptions;\n}): string => {\n  let requestString = \"\";\n  if (options && options.endpoint) {\n    requestString += `/${options.endpoint}`;\n  } else {\n    requestString = `/${kebabCase(resourceName)}`;\n  }\n  // If we have a specific resource or request type, append it to request URL\n  if (\n    (method === \"get\" && actionName !== \"search\" && resource.id) ||\n    method === \"delete\" ||\n    method === \"put\"\n  ) {\n    requestString += `/${resource.id}`;\n  }\n  if (actionName === \"search\") {\n    requestString += `/search?${qs.stringify(resource)}`;\n  }\n  return requestString;\n};\n\n/**\n * Get data from the API response.\n */\nasync function getDataFromAPIResponse({\n  response,\n  resource,\n  actionName,\n  transformIn\n}: {\n  response: Response;\n  resource: any;\n  actionName: string;\n  transformIn: (resource: any) => any;\n}) {\n  if (response.status < 200 || response.status > 299) {\n    throw new Error(`HTTP Error: ${response.status}`);\n  }\n  let data;\n  if (actionName === \"del\") {\n    data = resource;\n  } else {\n    // We take the data from the 'data' envelope, if it exists,\n    // or from the json directly if it doesn't.\n    // It'd be good to let the user provide an envelope.\n    const json: { data: any } = await response.json();\n    data = json.data ? json.data : json;\n    // Apply transforms\n    const dataIsArray = Array.isArray(data);\n    if (dataIsArray) {\n      data = data.map((item: any) => transformIn(item));\n    } else {\n      data = transformIn(data);\n    }\n  }\n  return data;\n}\n\n/**\n * Creates a saga that handles API operations.\n * Updates optimistically when updating or creating.\n *\n * @param {ICreateAPIActionOptions}\n */\nfunction createAPIAction({\n  resourceName,\n  baseUrl,\n  actionCreators,\n  actionName,\n  method,\n  selectAuthToken,\n  selectors,\n  relations,\n  transformIn,\n  transformOut\n}: ICreateAPIActionOptions): IAPIActionCreator {\n  /**\n   * Generator for the given action.\n   * Accepts FSA containing a payload with property 'resource' containing request data.\n   * Dispatches start (if applicable) action, makes HTTP calls, dispatches success/error actions with result.\n   */\n  return (payload?: IAPIActionParams) => async (dispatch: Dispatch<any>, getState: () => any) => {\n    // We store a client id here for optimistic creation\n    let resource;\n    let options;\n    let cid;\n    let authToken;\n    const state = getState();\n    const relationKeys = {} as { [relationId: string]: any[] };\n    const crudAction = mapActionToCRUDAction[actionName];\n    if (payload) {\n      ({ resource, options } = payload);\n    }\n    if (selectAuthToken) {\n      authToken = selectAuthToken(state);\n    }\n\n    let localResource = { ...resource };\n\n    // If we're creating a record, give it the client id if it doesn't have one already\n    if (actionName === \"create\") {\n      cid = localResource.id ? localResource.id : (localResource.id = v4());\n    }\n\n    // If we're updating a model, merge it with what's current in the state\n    if (actionName === \"update\") {\n      const modelFromState = selectors.findById(state, localResource.id);\n      if (!modelFromState) {\n        throw new Error(`Could not select model with id ${resource.id}`);\n      }\n      localResource = { ...modelFromState, ...localResource };\n    }\n\n    // Dispatch our start action, if there is one for the given action\n    if (resource && actionCreators[crudAction + \"Start\"]) {\n      if (relations && (actionName === \"update\" || actionName === \"create\")) {\n        const schema = Array.isArray(localResource) ? [relations.schema] : relations.schema;\n        const normalisedResource = normalize(localResource, schema);\n        const actions: any[] = [];\n        for (const i in relations.map) {\n          const relationData = normalisedResource.entities[i];\n          if (!relationData) {\n            continue;\n          }\n          // We store relation keys (cids) in order here.\n          // When we receive relation updates at the end of the action,\n          // we can replay these keys in order to sync with optimistic updates.\n          relationKeys[i] = [];\n\n          if (relationData.undefined) {\n            console.warn(`One or more of the relations you\\'re trying to ${actionName} is missing an id.\\\n\t\t\t\t\t\t\tBad things are likely to happen as a result.`);\n          }\n          Object.keys(relationData).forEach(id => {\n            relationKeys[i].push(id);\n            actions.push(relations.map[i][crudAction + \"Start\"](relationData[id]));\n          });\n        }\n        dispatch(batchActions(actions));\n      } else {\n        dispatch(actionCreators[crudAction + \"Start\"](localResource));\n      }\n    }\n\n    const contentType = getContentType(options);\n    const requestOptions = getRequestOptions({\n      resource: localResource,\n      actionName,\n      method,\n      contentType,\n      authToken,\n      transformOut\n    });\n    const requestString = getRequestString({\n      resource: localResource,\n      actionName,\n      method,\n      resourceName,\n      options\n    });\n\n    // Make the request and handle the response\n    try {\n      const response = await fetch(baseUrl + requestString, requestOptions);\n      const data = await getDataFromAPIResponse({\n        resource: localResource,\n        response,\n        actionName,\n        transformIn\n      });\n      // If there aren't any relations or we're not running a fetch or update, do a basic persist\n      if (!relations || (crudAction !== \"fetch\" && crudAction !== \"update\")) {\n        if (actionName === \"create\") {\n          dispatch(actionCreators[crudAction + \"Success\"](data, cid));\n        } else {\n          dispatch(actionCreators[crudAction + \"Success\"](data));\n        }\n      } else {\n        // If we do have relations, normalise the incoming data, and dispatch persist\n        // operations for each model. We check here to see if the data is an array (collection),\n        // and adjust the schema accordingly.\n        const normalisedData = normalize(\n          data,\n          Array.isArray(data) ? [relations.schema] : relations.schema\n        );\n        const actions: any[] = [];\n        for (const i in relations.map) {\n          const relationData = normalisedData.entities[i];\n          if (!relationData) {\n            continue;\n          }\n\n          Object.keys(relationData).forEach((id, index) => {\n            if (crudAction === \"fetch\") {\n              actions.push(relations.map[i][crudAction + \"Success\"](relationData[id]));\n            } else {\n              // We use the previously stored cid to reconcile updates here.\n              // It's imperative that relations come back in the same order they went out!\n              actions.push(\n                relations.map[i][crudAction + \"Success\"](\n                  relationData[id],\n                  relationKeys[i] ? relationKeys[i][index] : null\n                )\n              );\n            }\n          });\n        }\n        if (!actions.length) {\n          // If we haven't received any data, add a single success event.\n          // This will ensure that busy indicators are reset etc., and any\n          // consumer code watching for success actions will fire as expected.\n          actions.push(actionCreators[crudAction + \"Success\"]([]));\n        }\n        dispatch(batchActions(actions));\n      }\n      // Once we're done, call resolve for the Promise caller\n      return data;\n    } catch (e) {\n      if (method === \"get\") {\n        dispatch(actionCreators[crudAction + \"Error\"](e.message));\n      } else {\n        // Methods that persist data require the resource to revert optimistic updates\n        dispatch(actionCreators[crudAction + \"Error\"](e.message, localResource));\n      }\n      throw e;\n    }\n  };\n}\n\n// Selectors\n// ---------\n\n/**\n * Create selectors for the given resource namespace.\n *\n * @param {string} mountPoint - The name of the resource as appears in the state\n * @return {any} Object with selector methods\n */\nfunction createSelectors<IResource extends IBaseResource>(mountPoint: string) {\n  const getLocalState = (state: any): IState<IResource> => state[mountPoint];\n  return {\n    /**\n     * @inheritdocs\n     */\n    findById(state: any, id: number | string) {\n      return getLocalState(state).records[id] || null;\n    },\n\n    /**\n     * @inheritdocs\n     */\n    findByCid(state: any, cid: number | string) {\n      return find(\n        getLocalState(state).records,\n        (item: { _cid?: number | string }) => item._cid === cid\n      );\n    },\n\n    /**\n     * @inheritdocs\n     */\n    filter(\n      state: any,\n      predicate:\n        | string\n        | [string, any]\n        | ObjectIterator<\n            {\n              [key: string]: IResource;\n            },\n            boolean\n          >\n    ) {\n      return filter(getLocalState(state).records, predicate);\n    },\n\n    orderBy(state: any, iteratees: string[] | string, order: string[] | string) {\n      return orderBy(getLocalState(state).records, iteratees, order);\n    },\n\n    /**\n     * @inheritdocs\n     */\n    findAll(state: any) {\n      return getLocalState(state).records;\n    },\n\n    isResourceBusy(state: any) {\n      return getLocalState(state).busy;\n    },\n\n    isBusy(state: any, id: number | string) {\n      const record = getLocalState(state).records[id];\n      return record ? !!record.busy : false;\n    },\n\n    isPendingUpdate(state: any, id: number | string) {\n      const record = getLocalState(state).records[id];\n      return record ? !!record.pendingUpdate : false;\n    },\n\n    isPendingCreate(state: any, id: number | string) {\n      const record = getLocalState(state).records[id];\n      return record ? !!record.pendingCreate : false;\n    },\n\n    lastFetch(state: any) {\n      return getLocalState(state).lastFetch;\n    }\n  };\n}\n\nexport interface ICreateAPIResourceOptions {\n  // The name of the resource, conventionally in the singular\n  resourceName: string;\n  // The base url of the resource\n  baseUrl: string;\n  // The actions to add to the returned object\n  actions?: Array<ActionTypes>;\n  // Will be used to set basic auth headers\n  selectAuthToken?: (state: any) => string;\n  /**\n   * The relations options. We provide a Normalizr Schema object\n   * \there to process the incoming data, and a map between any additional entity names and\n   * \ttheir reducer functions. For example:\n   * ```js{\n   * \tschema: book,\n   * \tmap: {\n   * \t\tauthor: author.actions\n   * \t}\n   * }```\n   * would update authors nested in data returned from the Book resource.\n   */\n  relations?: {\n    schema: Schema;\n    map: {\n      [key: string]: any;\n    };\n  };\n  options?: {\n    // The function that models are passed through when they're received\n    transformIn: (model: any) => any;\n    // The function that models are passed through when they're sent\n    transformOut: (model: any) => any;\n  };\n}\n\nexport interface IBaseResource {\n  id: number | string;\n  _cid?: number | string;\n  busy?: boolean;\n  pendingUpdate?: boolean;\n  pendingCreate?: boolean;\n}\n\nexport interface IState<IResource extends IBaseResource> {\n  records: { [key: string]: IResource };\n  lastFetch: number | null;\n  busy: boolean;\n}\n\nconst initialState = {\n  records: {},\n  lastFetch: null,\n  busy: false\n};\n\n/**\n * Create the reduce for the given resource.\n */\nexport const createReducer = <\n  IResource extends IBaseResource,\n  IAction extends { type: string; time?: number }\n>(\n  resourceName: string,\n  actionNames: { [actionName: string]: string }\n) => {\n  const recordReducer = reduxCrud.Map.reducersFor(resourceName);\n  return (state: IState<IResource> = initialState, action: IAction): IState<IResource> => {\n    const newState = {\n      ...state,\n      records: recordReducer(state.records, action)\n    };\n    if (\n      action.type === actionNames.fetchStart ||\n      action.type === actionNames.createStart ||\n      action.type === actionNames.updateStart ||\n      action.type === actionNames.deleteStart\n    ) {\n      newState.busy = true;\n    }\n    if (\n      action.type === actionNames.fetchSuccess ||\n      action.type === actionNames.createSuccess ||\n      action.type === actionNames.updateSuccess ||\n      action.type === actionNames.deleteSuccess\n    ) {\n      // If there are no records that are still busy, mark the resource as unbusy.\n      if (!Object.keys(state.records).some(id => state.records[id] && !!state.records[id].busy)) {\n        newState.busy = false;\n      }\n      if (action.time) {\n        newState.lastFetch = action.time;\n      }\n    }\n    return newState;\n  };\n};\n\n/**\n * Create the action creators for the given resource.\n *\n * We augment some of the default 'success' action creators here to include a time property,\n * which lets the reducer store staleness information.\n */\nexport const createActionCreators = (resourceName: string) => {\n  const rawActionCreators = reduxCrud.actionCreatorsFor(resourceName);\n  const actionCreators = { ...rawActionCreators };\n  actionCreators.fetchSuccess = (records?: {}[] | undefined, data?: any) => {\n    return {\n      ...rawActionCreators.fetchSuccess(records, data),\n      time: Date.now()\n    };\n  };\n  actionCreators.updateSuccess = (records?: {} | undefined, data?: any) => {\n    return {\n      ...rawActionCreators.updateSuccess(records, data),\n      time: Date.now()\n    };\n  };\n  actionCreators.createSuccess = (records?: {} | undefined, data?: any) => {\n    return {\n      ...rawActionCreators.createSuccess(records, data),\n      time: Date.now()\n    };\n  };\n  return actionCreators;\n};\n\ntype TActionMap = ReturnType<typeof reduxCrud.actionCreatorsFor>;\ntype TActions = ReturnType<TActionMap[keyof TActionMap]>;\n\n/**\n * Creates an object with api methods keyed by name.\n * All of these actions can be dispatched as normal.\n * They will dispatch start (where available), success and error actions\n * in turn, making the http request to the API, the idea being, generic CRUD.\n *\n * @returns {IAPIResource}\n */\nfunction createAPIResource<IResource extends IBaseResource>({\n  resourceName,\n  baseUrl,\n  actions = availableActions,\n  selectAuthToken,\n  relations,\n  options = {\n    transformIn: identity,\n    transformOut: identity\n  }\n}: ICreateAPIResourceOptions) {\n  const actionCreators = createActionCreators(resourceName);\n  const selectors = createSelectors<IResource>(resourceName);\n  const actionNames = reduxCrud.actionTypesFor(resourceName);\n  const apiResource = {\n    thunks: {} as { [action: string]: IAPIActionCreator },\n    actions: actionCreators,\n    actionNames: {} as { [actionName: string]: string },\n    selectors,\n    reducers: createReducer<IResource, TActions>(resourceName, actionNames)\n  };\n\n  // Create a resource for each of our actions\n  actions.forEach(actionName => {\n    if (!mapActionToHTTPMethod[actionName]) {\n      throw new Error(`Method ${actionName} not supported for resource ${resourceName}`);\n    }\n\n    // If we've got relations, add the root relation to the relations map.\n    // This saves us doing it for every persist operation, and lets us iterate\n    // over the whole resource with the relations map.\n    if (relations) {\n      relations.map[resourceName] = actionCreators;\n    }\n\n    apiResource.actionNames = actionNames;\n\n    // Create the worker saga\n    apiResource.thunks[actionName] = createAPIAction({\n      resourceName,\n      baseUrl,\n      actionCreators,\n      selectors,\n      actionName,\n      method: mapActionToHTTPMethod[actionName],\n      selectAuthToken,\n      relations,\n      transformIn: options.transformIn || identity,\n      transformOut: options.transformOut || identity\n    });\n  });\n  return apiResource;\n}\n\nexport default createAPIResource;\n"],"names":["qs.stringify"],"mappings":"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"}